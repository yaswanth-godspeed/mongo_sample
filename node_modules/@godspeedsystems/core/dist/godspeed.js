/* eslint-disable import/first */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GSActor: function() {
        return _interfaces.GSActor;
    },
    GSCloudEvent: function() {
        return _interfaces.GSCloudEvent;
    },
    GSContext: function() {
        return _interfaces.GSContext;
    },
    GSDataSource: function() {
        return _sources.GSDataSource;
    },
    GSDataSourceAsEventSource: function() {
        return _sources.GSDataSourceAsEventSource;
    },
    GSEventSource: function() {
        return _sources.GSEventSource;
    },
    GSResponse: function() {
        return _interfaces.GSResponse;
    },
    GSStatus: function() {
        return _interfaces.GSStatus;
    },
    PlainObject: function() {
        return _types.PlainObject;
    },
    default: function() {
        return _default;
    }
});
const _path = require("path");
const _process = require("process");
const _swaggeruiexpress = /*#__PURE__*/ _interop_require_default(require("swagger-ui-express"));
const _metrics = /*#__PURE__*/ _interop_require_default(require("@godspeedsystems/metrics"));
const _definitionsLoader = /*#__PURE__*/ _interop_require_default(require("./core/definitionsLoader"));
const _datasourceLoader = /*#__PURE__*/ _interop_require_default(require("./core/datasourceLoader"));
const _eventsourceLoader = /*#__PURE__*/ _interop_require_default(require("./core/eventsourceLoader"));
const _functionLoader = /*#__PURE__*/ _interop_require_default(require("./core/functionLoader"));
const _eventLoader = /*#__PURE__*/ _interop_require_default(require("./core/eventLoader"));
const _mappingLoader = /*#__PURE__*/ _interop_require_default(require("./core/mappingLoader"));
const _interfaces = require("./core/interfaces");
const _sources = require("./core/_interfaces/sources");
const _types = require("./types");
const _jsonSchemaValidation = require("./core/jsonSchemaValidation");
const _logger = require("./logger");
const _swagger = require("./router/swagger");
function _async_iterator(iterable) {
    var method, async, sync, retry = 2;
    for("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;){
        if (async && null != (method = iterable[async])) return method.call(iterable);
        if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
        async = "@@asyncIterator", sync = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
    function AsyncFromSyncIteratorContinuation(r) {
        if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
        var done = r.done;
        return Promise.resolve(r.value).then(function(value) {
            return {
                value: value,
                done: done
            };
        });
    }
    return AsyncFromSyncIterator = function(s) {
        this.s = s, this.n = s.next;
    }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function() {
            return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        return: function(value) {
            var ret = this.s.return;
            return void 0 === ret ? Promise.resolve({
                value: value,
                done: !0
            }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
        },
        throw: function(value) {
            var thr = this.s.return;
            return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
        }
    }, new AsyncFromSyncIterator(s);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
require('dotenv').config();
try {
    if (process.env.OTEL_ENABLED == 'true') {
        require('@godspeedsystems/tracing').initialize();
    }
} catch (error) {
    console.error("OTEL_ENABLED is set, unable to initialize opentelemetry tracing.");
    console.error(error);
    process.exit(1);
}
var config = require('config');
class Godspeed {
    initilize() {
        var _this = this;
        this._loadDefinitions().then(function() {
            var _ref = _async_to_generator(function*(definitions) {
                _this.definitions = definitions;
                _this.mappings = yield _this._loadMappings();
                let datasources = yield _this._loadDatasources();
                _this.datasources = datasources;
                let functions = yield _this._loadFunctions();
                _this.workflows = functions;
                let eventsources = yield _this._loadEventsources();
                _this.eventsources = eventsources;
                let events = yield _this._loadEvents();
                _this.events = events;
                yield _this.subscribeToEvents();
                let status = Object.keys(eventsources).map((esName)=>{
                    let es = eventsources[esName];
                    return `${es.config.type}: ${es.config.port}`;
                }).join(' ');
                _logger.logger.info(`[${_this.isProd ? 'Production' : 'Dev'} Server][Running] ('${status.split(' ')[0]}' event source, '${status.split(' ')[1]}' port).`);
            });
            return function(definitions) {
                return _ref.apply(this, arguments);
            };
        }()).catch((error)=>{
            _logger.logger.error(error.message);
        });
    }
    initialize() {
        this.initilize();
    }
    _loadMappings() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load mappings from %s', _this.folderPaths.mappings);
            let mappings = (0, _mappingLoader.default)(_this.folderPaths.mappings);
            _logger.logger.debug('Mappings %o', mappings);
            _logger.logger.info('[END] Load mappings');
            return mappings;
        })();
    }
    _loadEvents() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load events from %s', _this.folderPaths.events);
            let events = yield (0, _eventLoader.default)(_this.workflows, _this.folderPaths.events);
            _logger.logger.debug('Events %o', events);
            _logger.logger.info('[END] Load events');
            return events;
        })();
    }
    _loadDefinitions() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load definitions from %s', _this.folderPaths.definitions);
            const definitions = yield (0, _definitionsLoader.default)(_this.folderPaths.definitions);
            _logger.logger.debug('Definitions %o', definitions);
            _logger.logger.info('[END] Load definitions');
            return definitions;
        })();
    }
    _loadFunctions() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load functions from %s', _this.folderPaths.workflows);
            const loadFnStatus = yield (0, _functionLoader.default)(_this.datasources, _this.folderPaths.workflows);
            _logger.logger.debug('Functions %o', Object.keys(loadFnStatus.functions));
            if (loadFnStatus.success) {
                _logger.logger.info('[END] Load functions');
                return loadFnStatus.functions;
            } else {
                throw new Error(`Failed to load functions.`);
            }
        })();
    }
    _loadDatasources() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load data sources from %s', _this.folderPaths.datasources);
            let datasources = yield (0, _datasourceLoader.default)(_this.folderPaths.datasources);
            _logger.logger.debug('data sources %o', datasources);
            _logger.logger.info('[END] Load data sources');
            return datasources;
        })();
    }
    _loadEventsources() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load event sources from %s', _this.folderPaths.eventsources);
            let eventsources = yield (0, _eventsourceLoader.default)(_this.folderPaths.eventsources, _this.datasources);
            _logger.logger.debug('event sources %o', eventsources);
            _logger.logger.info('[END] event sources.');
            return eventsources;
        })();
    }
    subscribeToEvents() {
        var _this = this;
        return _async_to_generator(function*() {
            var _httpEventSource_config;
            const httpEvents = {};
            {
                var _iteratorAbruptCompletion = false, _didIteratorError = false, _iteratorError;
                try {
                    for(var _iterator = _async_iterator(Object.keys(_this.events)), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false){
                        let _value = _step.value;
                        const route = _value;
                        let eventKey = route;
                        let eventSourceName = route.split('.')[0];
                        const eventSource = _this.eventsources[eventSourceName];
                        // for swagger UI
                        if (eventSourceName === 'http') {
                            httpEvents[eventKey] = _object_spread({}, _this.events[eventKey]);
                        }
                        const processEventHandler = yield _this.processEvent(_this);
                        yield eventSource.subscribeToEvent(route, _this.events[eventKey], processEventHandler, _object_spread({}, _this.events[route]));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (_iteratorAbruptCompletion && _iterator.return != null) {
                            yield _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            const httpEventSource = _this.eventsources['http']; // eslint-disable-line
            if (httpEventSource === null || httpEventSource === void 0 ? void 0 : (_httpEventSource_config = httpEventSource.config) === null || _httpEventSource_config === void 0 ? void 0 : _httpEventSource_config.docs) {
                const _httpEvents = (0, _swagger.generateSwaggerJSON)(httpEvents, _this.definitions, httpEventSource.config);
                // @ts-ignore
                httpEventSource.client.use(httpEventSource.config.docs.endpoint || '/api-docs', _swaggeruiexpress.default.serve, _swaggeruiexpress.default.setup(_httpEvents));
            }
            if (process.env.OTEL_ENABLED == 'true') {
                // @ts-ignore
                httpEventSource.client.get('/metrics', function() {
                    var _ref = _async_to_generator(function*(req, res) {
                        let prismaMetrics = '';
                        for(let ds in _this.datasources){
                            // @ts-ignore
                            if (_this.datasources[ds].config.type === 'prisma') {
                                // @ts-ignore
                                prismaMetrics += yield _this.datasources[ds].client.$metrics.prometheus({
                                    globalLabels: {
                                        server: process.env.HOSTNAME,
                                        datasource: `${ds}`
                                    }
                                });
                            }
                        }
                        let appMetrics = yield _metrics.default.register.metrics();
                        res.end(appMetrics + prismaMetrics);
                    });
                    return function(req, res) {
                        return _ref.apply(this, arguments);
                    };
                }());
            }
        })();
    }
    processEvent(local) {
        return _async_to_generator(function*() {
            const { workflows, datasources, mappings } = local;
            return function() {
                var _ref = _async_to_generator(function*(event, eventConfig) {
                    // TODO: improve child logger initilization
                    // initilize child logger
                    (0, _logger.initializeChildLogger)({});
                    // TODO: lot's of logging related steps
                    _logger.childLogger.info('processing event ... %s %o', event.type);
                    // TODO: Once the config loader is sorted, fetch the apiVersion from config
                    const responseStructure = {
                        apiVersion: '1.0'
                    };
                    let eventHandlerWorkflow;
                    let validateStatus = (0, _jsonSchemaValidation.validateRequestSchema)(event.type, event, eventConfig);
                    let eventSpec = eventConfig;
                    if (validateStatus.success === false) {
                        _logger.childLogger.error('failed to validate request body.', validateStatus);
                        const responseData = {
                            message: 'request validation failed.',
                            error: validateStatus.message,
                            data: validateStatus.data
                        };
                        // if `on_validation_error` is defined in the event, let's execute that
                        if (eventSpec.on_validation_error) {
                            const validationError = _object_spread({
                                success: false,
                                code: validateStatus.code
                            }, responseData);
                            _logger.childLogger.error(validationError);
                            event.data = {
                                event: event.data,
                                validation_error: validationError
                            };
                            // A workflow is always a series execution of its tasks. ie., a GSSeriesFunction
                            eventHandlerWorkflow = workflows[eventSpec.on_validation_error];
                        } else {
                            return validateStatus;
                        }
                    } else {
                        _logger.childLogger.info('Request JSON Schema validated successfully %o', validateStatus);
                        eventHandlerWorkflow = workflows[eventSpec.fn];
                    }
                    const ctx = new _interfaces.GSContext(config, datasources, event, mappings, {}, _logger.logger, _logger.childLogger);
                    let eventHandlerStatus;
                    try {
                        const eventHandlerResponse = yield eventHandlerWorkflow(ctx);
                        // The final status of the handler workflow is calculated from the last task of the handler workflow (series function)
                        eventHandlerStatus = ctx.outputs[eventHandlerWorkflow.id] || eventHandlerResponse;
                        _logger.childLogger.info('eventHandlerStatus: %o', eventHandlerStatus);
                        if (eventHandlerStatus.success) {
                            // event workflow executed successfully
                            // lets validate the response schema
                            let validateResponseStatus = (0, _jsonSchemaValidation.validateResponseSchema)(event.type, eventHandlerStatus);
                            if (!validateResponseStatus.success) {
                                _logger.childLogger.error('Response JSON schema validation failed.');
                                return new _interfaces.GSStatus(false, 500, 'response validation error', {
                                    error: {
                                        message: validateResponseStatus.message,
                                        info: validateResponseStatus.data
                                    }
                                });
                            }
                        }
                        return eventHandlerStatus;
                    } catch (error) {
                        return new _interfaces.GSStatus(false, 500, `Error in executing handler ${eventSpec.fn} for the event ${event.type} `, error);
                    }
                });
                return function(event, eventConfig) {
                    return _ref.apply(this, arguments);
                };
            }();
        })();
    }
    constructor(params = {}){
        _define_property(this, "datasources", {});
        _define_property(this, "eventsources", {});
        _define_property(this, "workflows", {});
        _define_property(this, "events", {});
        _define_property(this, "definitions", {});
        _define_property(this, "config", {});
        _define_property(this, "mappings", {});
        _define_property(this, "isProd", process.env.NODE_ENV === 'production');
        _define_property(this, "folderPaths", void 0);
        // config
        this.config = config;
        // let's assume we a re getting the current directory, where module is imported
        const currentDir = (0, _process.cwd)();
        // destruct GodspeedParams, if not supplied, assign the default value
        let { eventsFolderPath, workflowsFolderPath, definitionsFolderPath, configFolderPath, datasourcesFolderPath, eventsourcesFolderPath, mappingsFolderPath } = params;
        eventsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.eventsFolderPath || '/dist/events' : params.eventsFolderPath || '/src/events');
        workflowsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.workflowsFolderPath || '/dist/functions' : params.workflowsFolderPath || '/src/functions');
        definitionsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.definitionsFolderPath || '/dist/definitions' : params.definitionsFolderPath || '/src/definitions');
        configFolderPath = (0, _path.join)(currentDir, this.isProd ? params.configFolderPath || '/config' : params.configFolderPath || '/config');
        datasourcesFolderPath = (0, _path.join)(currentDir, this.isProd ? params.datasourcesFolderPath || '/dist/datasources' : params.datasourcesFolderPath || '/src/datasources');
        eventsourcesFolderPath = (0, _path.join)(currentDir, this.isProd ? params.eventsourcesFolderPath || '/dist/eventsources' : params.eventsourcesFolderPath || '/src/eventsources');
        mappingsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.mappingsFolderPath || '/dist/mappings' : params.mappingsFolderPath || '/src/mappings');
        this.folderPaths = {
            events: eventsFolderPath,
            workflows: workflowsFolderPath,
            config: configFolderPath,
            definitions: definitionsFolderPath,
            datasources: datasourcesFolderPath,
            eventsources: eventsourcesFolderPath,
            mappings: mappingsFolderPath
        };
        Object.freeze(this.folderPaths);
    }
}
const _default = Godspeed;
