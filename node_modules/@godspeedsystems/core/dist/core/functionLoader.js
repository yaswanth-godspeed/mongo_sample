/*
* You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
* Â© 2022 Mindgrep Technologies Pvt Ltd
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createGSFunction: function() {
        return createGSFunction;
    },
    default: function() {
        return loadFunctions;
    }
});
const _interfaces = require("./interfaces");
const _utils = require("./utils");
const _yamlLoader = /*#__PURE__*/ _interop_require_default(require("./yamlLoader"));
const _codeLoader = /*#__PURE__*/ _interop_require_default(require("./codeLoader"));
const _logger = require("../logger");
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
let lastIfFn;
function createGSFunction(workflowJson, workflows, nativeFunctions, onError) {
    var _workflowJson_on_error;
    _logger.logger.debug('Creating GSFunction %s workflow_name %s', workflowJson.id, workflowJson.workflow_name);
    if (!workflowJson.fn) {
        if (Array.isArray(workflowJson)) {
            // @ts-ignore
            workflowJson = {
                tasks: workflowJson,
                fn: 'com.gs.sequential',
                workflow_name: workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.workflow_name
            };
        } else {
            workflowJson.fn = 'com.gs.sequential';
        }
    }
    let tasks;
    switch(workflowJson.fn){
        case 'com.gs.sequential':
            tasks = workflowJson.tasks.map((taskJson)=>{
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            return new _interfaces.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
        case 'com.gs.dynamic_fn':
            tasks = workflowJson.tasks.map((taskJson)=>{
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            return new _interfaces.GSDynamicFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
        case 'com.gs.parallel':
            tasks = workflowJson.tasks.map((taskJson)=>{
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            return new _interfaces.GSParallelFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
        case 'com.gs.switch':
            {
                let args = [
                    workflowJson.value
                ];
                let cases = {};
                for(let c in workflowJson.cases){
                    workflowJson.cases[c].workflow_name = workflowJson.workflow_name;
                    cases[c] = createGSFunction(workflowJson.cases[c], workflows, nativeFunctions, onError);
                }
                if (workflowJson.defaults) {
                    workflowJson.defaults.workflow_name = workflowJson.workflow_name;
                    cases.default = createGSFunction(workflowJson.defaults, workflows, nativeFunctions, onError);
                }
                args.push(cases);
                _logger.logger.debug('loading switch workflow %o', workflowJson.cases);
                return new _interfaces.GSSwitchFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
            }
        case 'com.gs.if':
            {
                let args = [
                    workflowJson.condition
                ];
                tasks = workflowJson.tasks.map((taskJson)=>{
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
                tasks = tasks.filter(Boolean);
                let task = new _interfaces.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
                args.push(task);
                lastIfFn = new _interfaces.GSIFFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
                return lastIfFn;
            }
        case 'com.gs.elif':
            {
                let args = [
                    workflowJson.condition
                ];
                tasks = workflowJson.tasks.map((taskJson)=>{
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
                tasks = tasks.filter(Boolean);
                let task = new _interfaces.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
                args.push(task);
                let fn = new _interfaces.GSIFFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
                if (!lastIfFn) {
                    _logger.logger.error(`If is missing before elsif ${workflowJson.id}.`);
                    throw new Error(`If is missing before elsif ${workflowJson.id}.`);
                } else {
                    lastIfFn.else_fn = fn;
                }
                lastIfFn = fn;
                return null;
            }
        case 'com.gs.else':
            {
                tasks = workflowJson.tasks.map((taskJson)=>{
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
                tasks = tasks.filter(Boolean);
                let task = new _interfaces.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
                if (!lastIfFn) {
                    _logger.logger.error(`If is missing before else ${workflowJson.id}.`);
                    throw new Error(`If is missing before else ${workflowJson.id}.`);
                } else {
                    lastIfFn.else_fn = task;
                }
                lastIfFn = null;
                return null;
            }
        case 'com.gs.each_parallel':
            {
                var _workflowJson_on_error1;
                let args = [
                    workflowJson.value
                ];
                let tasks = workflowJson.tasks.map((taskJson)=>{
                    taskJson.workflow_name = workflowJson.workflow_name;
                    taskJson.isEachParallel = true;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
                tasks = tasks.filter(Boolean);
                let task = new _interfaces.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
                args.push(task);
                if (workflowJson === null || workflowJson === void 0 ? void 0 : (_workflowJson_on_error1 = workflowJson.on_error) === null || _workflowJson_on_error1 === void 0 ? void 0 : _workflowJson_on_error1.tasks) {
                    workflowJson.on_error.tasks.workflow_name = workflowJson.workflow_name;
                    workflowJson.on_error.tasks = createGSFunction(workflowJson.on_error.tasks, workflows, nativeFunctions, null);
                }
                _logger.logger.debug('loading each parallel workflow %o', workflowJson.tasks);
                return new _interfaces.GSEachParallelFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
            }
        case 'com.gs.each_sequential':
            {
                var _workflowJson_on_error2;
                let args = [
                    workflowJson.value
                ];
                let tasks = workflowJson.tasks.map((taskJson)=>{
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
                tasks = tasks.filter(Boolean);
                let task = new _interfaces.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
                args.push(task);
                if (workflowJson === null || workflowJson === void 0 ? void 0 : (_workflowJson_on_error2 = workflowJson.on_error) === null || _workflowJson_on_error2 === void 0 ? void 0 : _workflowJson_on_error2.tasks) {
                    workflowJson.on_error.tasks.workflow_name = workflowJson.workflow_name;
                    workflowJson.on_error.tasks = createGSFunction(workflowJson.on_error.tasks, workflows, nativeFunctions, null);
                }
                _logger.logger.debug('loading each sequential workflow %o', workflowJson.tasks);
                return new _interfaces.GSEachSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
            }
    }
    let subwf = false;
    let fn;
    let fnScript;
    if (workflowJson.fn.match(/<(.*?)%/) && workflowJson.fn.includes('%>')) {
        fnScript = (0, _utils.compileScript)(workflowJson.fn);
    } else {
        // Load the fn for this GSFunction
        _logger.logger.debug('workflowJson.fn %s', workflowJson.fn);
        // first check if it's a native function
        // but, special handling for datasource function, because
        // while using datasource fn: in workflows, it is in this format, `datasource.{datasourceName}.{entityName}.{method}`
        // where as, datasource function are registered as `datasource.{datasourceName}`
        let fnName = String(workflowJson.fn).startsWith('datasource.') ? String(workflowJson.fn).split('.').splice(0, 2).join('.') : workflowJson.fn;
        fn = nativeFunctions[fnName];
        if (!fn) {
            const existingWorkflowData = workflows[fnName];
            if (!existingWorkflowData) {
                throw new Error(`Function specified by name ${fnName} not found in src/functions. Please ensure a function by this path exists.`);
            }
            subwf = true;
            if (!(existingWorkflowData instanceof _interfaces.GSFunction)) {
                existingWorkflowData.workflow_name = fnName;
                fn = workflows[fnName] = createGSFunction(existingWorkflowData, workflows, nativeFunctions, onError);
            } else {
                fn = existingWorkflowData;
            }
        }
    }
    if (workflowJson === null || workflowJson === void 0 ? void 0 : (_workflowJson_on_error = workflowJson.on_error) === null || _workflowJson_on_error === void 0 ? void 0 : _workflowJson_on_error.tasks) {
        workflowJson.on_error.tasks.workflow_name = workflowJson.workflow_name;
        workflowJson.on_error.tasks = createGSFunction(workflowJson.on_error.tasks, workflows, nativeFunctions, null);
    } else if (workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.on_error) {
    // do nothing
    } else if (onError) {
        workflowJson.on_error = onError;
    }
    if (workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.authz) {
        workflowJson.authz.workflow_name = workflowJson.workflow_name;
        workflowJson.authz = createGSFunction(workflowJson.authz, workflows, nativeFunctions, onError);
    }
    return new _interfaces.GSFunction(workflowJson, workflows, nativeFunctions, fn, workflowJson.args, subwf, fnScript);
}
function loadFunctions(datasources, pathString) {
    return _loadFunctions.apply(this, arguments);
}
function _loadFunctions() {
    _loadFunctions = _async_to_generator(function*(datasources, pathString) {
        // framework defined js/ts functions
        let code = yield (0, _codeLoader.default)(_path.default.resolve(__dirname, '../functions'));
        // project defined yaml worlflows
        let functions = yield (0, _yamlLoader.default)(pathString);
        // project defined js/ts functions
        let jsCode = yield (0, _codeLoader.default)(pathString);
        let loadFnStatus;
        _logger.logger.debug('JS functions %s', Object.keys(jsCode));
        _logger.logger.debug('Yaml Workflows %s', Object.keys(functions));
        _logger.logger.debug('Framework defined  functions %s', Object.keys(functions));
        _logger.logger.debug('Datasource Functions %o', Object.keys(datasources));
        let _datasourceFunctions = Object.keys(datasources).reduce((acc, dsName)=>{
            // @ts-ignore
            // dsName, eg., httpbin, mongo, prostgres, salesforce
            acc[`datasource.${dsName}`] = function() {
                var _ref = _async_to_generator(function*(ctx, args) {
                    return datasources[dsName].execute(ctx, args);
                });
                return function(ctx, args) {
                    return _ref.apply(this, arguments);
                };
            }();
            return acc;
        }, {});
        code = _object_spread({}, code, _datasourceFunctions, jsCode);
        for(let f in functions){
            try {
                if (!functions[f].tasks) {
                    throw new Error(`Error in loading tasks of function ${f}.`);
                }
            } catch (ex) {
                ex.message = `Error in loading tasks of function ${f}.` + ex.message;
                throw ex;
            }
            const checkDS = (0, _utils.checkDatasource)(functions[f], datasources);
            if (!checkDS.success) {
                throw new Error(`Error in loading datasource for function ${f} . Error message: ${checkDS.message}. Exiting.`);
            }
        }
        _logger.logger.debug('Creating workflows: %s', Object.keys(functions));
        for(let f in functions){
            if (!(functions[f] instanceof _interfaces.GSFunction)) {
                var _functions_f_on_error;
                functions[f].workflow_name = f;
                if ((_functions_f_on_error = functions[f].on_error) === null || _functions_f_on_error === void 0 ? void 0 : _functions_f_on_error.tasks) {
                    functions[f].on_error.tasks.workflow_name = f;
                    functions[f].on_error.tasks = createGSFunction(functions[f].on_error.tasks, functions, code, null);
                }
                functions[f] = createGSFunction(functions[f], functions, code, functions[f].on_error);
            }
        }
        loadFnStatus = {
            success: true,
            functions: _object_spread({}, functions, jsCode)
        };
        _logger.logger.info('Loaded YAML workflows: %o', Object.keys(functions));
        _logger.logger.info('Loaded JS workflows %o', Object.keys(jsCode));
        return loadFnStatus;
    });
    return _loadFunctions.apply(this, arguments);
}
