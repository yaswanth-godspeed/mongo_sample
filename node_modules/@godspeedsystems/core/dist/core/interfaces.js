/*
* You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
* Â© 2022 Mindgrep Technologies Pvt Ltd
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GSActor: function() {
        return GSActor;
    },
    GSCloudEvent: function() {
        return GSCloudEvent;
    },
    GSContext: function() {
        return GSContext;
    },
    GSDynamicFunction: function() {
        return GSDynamicFunction;
    },
    GSEachParallelFunction: function() {
        return GSEachParallelFunction;
    },
    GSEachSeriesFunction: function() {
        return GSEachSeriesFunction;
    },
    GSFunction: function() {
        return GSFunction;
    },
    GSIFFunction: function() {
        return GSIFFunction;
    },
    GSLogEvent: function() {
        return GSLogEvent;
    },
    GSParallelFunction: function() {
        return GSParallelFunction;
    },
    GSSeriesFunction: function() {
        return GSSeriesFunction;
    },
    GSStatus: function() {
        return GSStatus;
    },
    GSSwitchFunction: function() {
        return GSSwitchFunction;
    }
});
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _parseduration = /*#__PURE__*/ _interop_require_default(require("parse-duration"));
const _api = /*#__PURE__*/ _interop_require_default(require("@opentelemetry/api"));
const _logger = require("../logger");
const _utils = require("./utils");
const _scriptRuntime = /*#__PURE__*/ _interop_require_default(require("./scriptRuntime"));
const _metrics = /*#__PURE__*/ _interop_require_default(require("@godspeedsystems/metrics"));
const _config = /*#__PURE__*/ _interop_require_default(require("config"));
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
const tracer = _api.default.trace.getTracer('my-service-tracer');
class GSFunction extends Function {
    _internalCall(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            var _this_logs, _this_logs1;
            if ((_this_logs = _this.logs) === null || _this_logs === void 0 ? void 0 : _this_logs.before) {
                const log = _this.logs.before;
                //@ts-ignore
                ctx.childLogger[log.level](log.attributes ? yield (0, _scriptRuntime.default)(ctx, log.attributes, taskValue) : null, `${log.message} %o`, log.params);
            }
            const timers = [];
            if (_this.metrics) {
                for (let metric of _this.metrics){
                    if (metric.timer) {
                        //@ts-ignore
                        timers.push(metric.obj.startTimer());
                    }
                }
            }
            const status = yield _this._call(ctx, taskValue);
            if (_this.metrics) {
                for (let timer of timers){
                    //@ts-ignore
                    timer();
                }
                for (let metric of _this.metrics){
                    let obj = metric.obj;
                    for (let key of Object.keys(metric)){
                        if (![
                            'type',
                            'name',
                            'obj',
                            'timer',
                            'help'
                        ].includes(key)) {
                            const val = yield (0, _scriptRuntime.default)(ctx, metric[key], taskValue);
                            obj = obj[key](val);
                        }
                    }
                }
            }
            if ((_this_logs1 = _this.logs) === null || _this_logs1 === void 0 ? void 0 : _this_logs1.after) {
                const log = _this.logs.after;
                //@ts-ignore
                ctx.childLogger[log.level](log.attributes ? yield (0, _scriptRuntime.default)(ctx, log.attributes, taskValue) : null, `${log.message} %o`, log.params);
            }
            return status;
        })();
    }
    _observability(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this.yaml.trace) {
                let trace = _this.yaml.trace;
                return tracer.startActiveSpan(trace.name, function() {
                    var _ref = _async_to_generator(function*(span) {
                        if (trace.attributes) {
                            trace.attributes.task_id = _this.id;
                            trace.attributes.workflow_name = _this.workflow_name;
                            for(let attr in trace.attributes){
                                span.setAttribute(attr, trace.attributes[attr]);
                            }
                        }
                        const status = yield _this._internalCall(ctx, taskValue);
                        if (!status.success) {
                            span.setStatus({
                                //@ts-ignore
                                code: _api.default.SpanStatusCode.ERROR,
                                message: 'Error'
                            });
                        }
                        span.end();
                        return status;
                    });
                    return function(span) {
                        return _ref.apply(this, arguments);
                    };
                }());
            } else {
                return _this._internalCall(ctx, taskValue);
            }
        })();
    }
    _executefn(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            // final status to return
            let status;
            let args = _this.args;
            try {
                ctx.childLogger.info({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, 'Executing handler %s %o', _this.id, _this.args);
                if (Array.isArray(_this.args)) {
                    args = [
                        ..._this.args
                    ];
                } else if (_lodash.default.isPlainObject(_this.args)) {
                    args = _object_spread({}, _this.args);
                }
                ctx.childLogger.debug({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, 'Retry logic is %o', _this.retry);
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                if (String(_this.yaml.fn).startsWith('datasource.')) {
                    // If datasource is a script then evaluate it else load ctx.datasources as it is.
                    const [, datasourceName, entityType, method] = _this.yaml.fn.split('.');
                    const datasource = ctx.datasources[datasourceName];
                    // so that prisma plugin get the entityName and method in plugin to execute respective method.
                    args.meta = {
                        fnNameInWorkflow: _this.yaml.fn,
                        entityType,
                        method
                    };
                    // REMOVE: this is not required, because now all the datasources are functions
                    // if (datasource instanceof Function) {
                    //   args.datasource = await evaluateScript(ctx, datasource, taskValue);
                    //   ctx.childLogger.info({ 'workflow_name': this.workflow_name, 'task_id': this.id }, 'datasource evaluated');
                    // } else {
                    //   args.datasource = datasource;
                    //   ctx.childLogger.info({ 'workflow_name': this.workflow_name, 'task_id': this.id }, 'datasource %o', args.datasource);
                    // }
                    // copy datasource headers to args.config.headers [This is useful to define the headers at datasource level
                    // so that datasource headers are passed to all the workflows using this datasource]
                    let headers = datasource.config.headers;
                    if (headers) {
                        args.headers = args.headers || {};
                        let tempObj = {};
                        Object.keys(_object_spread({}, headers, args.headers)).map((key)=>{
                            tempObj[key] = args.headers[key] || headers[key];
                        });
                        Object.assign(args.headers, tempObj);
                        Object.keys(args.headers).forEach((key)=>args.headers[key] === undefined && delete args.headers[key]);
                        ctx.childLogger.info({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        }, `settings datasource headers: %o`, args.headers);
                    }
                // TODO: this will be moved to datasource plugin
                // if (ds.authn && !datasource.authn_response) {
                //   ctx.childLogger.info({ 'workflow_name': this.workflow_name, 'task_id': this.id }, 'Executing datasource authn workflow');
                //   datasource.authn_response = await authnWorkflow(ds, ctx);
                // }
                // TODO: this will be moved to datasource plugin
                // if (ds.before_method_hook) {
                //   await ds.before_method_hook(ctx);
                // }
                }
                // TODO: look back
                // if (args && ctx.inputs.metadata?.messagebus?.kafka) {  //com.gs.kafka will always have args
                //   args.kafka = ctx.inputs.metadata?.messagebus.kafka;
                // }
                // Generally all methods with retry will have some args
                if (args && _this.retry) {
                    args.retry = _this.retry;
                }
                let res;
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                if (Array.isArray(args)) {
                    res = yield _this.fn(ctx, args);
                } else {
                    res = yield _this.fn(ctx, args);
                }
                ctx.childLogger.info({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, `Result of _executeFn ${_this.id} %o`, res);
                if (res instanceof GSStatus) {
                    status = res;
                } else {
                    if (typeof res == 'object' && (res.success !== undefined || res.code !== undefined)) {
                        //Some framework functions like HTTP return an object in following format. Check if that is the case.
                        //All framework functions are expected to set success as boolean variable. Can not be null.
                        let { success, code, data, message, headers, exitWithStatus } = res;
                        status = new GSStatus(success, code, message, data, headers);
                        //Check if exitWithStatus is set in the res object. If it is set then return by setting ctx.exitWithStatus else continue.
                        if (exitWithStatus) {
                            ctx.exitWithStatus = status;
                        }
                    } else {
                        //This function gives a non GSStatus compliant return, then create a new GSStatus and set in the output for this function
                        status = new GSStatus(true, 200, undefined, res);
                    }
                }
            } catch (err) {
                ctx.childLogger.error({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, 'Caught error from execution in task id: %s, error: %s', _this.id, err);
                status = new GSStatus(false, 500, err.message, `Caught error from execution in task id: ${_this.id}, error: ${err}`);
            }
            // TODO: move it to datasource
            // if (args.datasource?.after_method_hook) {
            //   ctx.outputs.current_output = status;
            //   await args.datasource.after_method_hook(ctx);
            // }
            return status;
        })();
    }
    handleError(ctx, status, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!status.success) {
                /**
      * If the call had an error, set that in events so that we can send it to the telemetry backend.
      */ ctx.addLogEvent(new GSLogEvent('ERROR', ctx.outputs));
                if (_this.onError) {
                    ctx.outputs[_this.id] = status;
                    if (_this.onError.response instanceof Function) {
                        //The script may need the output of the task so far, for the transformation logic.
                        //So set the status in outputs, against this task's id
                        const res = yield (0, _scriptRuntime.default)(ctx, _this.onError.response, taskValue);
                        if (typeof res === 'object' && !(res.success === undefined && res.code === undefined)) {
                            let { success, code, data, message, headers } = res;
                            status = new GSStatus(success, code, message, data, headers);
                        } else {
                            //This function gives a non GSStatus compliant return, then create a new GSStatus and set in the output for this function
                            status = new GSStatus(true, 200, undefined, res);
                        }
                    } else if (_this.onError.response) {
                        status.data = _this.onError.response;
                    } else if (_this.onError.tasks) {
                        status = yield _this.onError.tasks(ctx);
                    }
                    if (_this.onError.log_attributes) {
                        const error = {};
                        const logAttributes = _this.onError.log_attributes;
                        for(let key in logAttributes){
                            const script = (0, _utils.compileScript)(logAttributes[key]);
                            error[key] = yield (0, _scriptRuntime.default)(ctx, script, taskValue);
                        }
                        ctx.childLogger.setBindings({
                            error
                        });
                    }
                    if (_this.onError.continue === false) {
                        ctx.childLogger.debug({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        }, 'exiting on error %s', _this.id);
                        ctx.exitWithStatus = status;
                    }
                } else {
                    if (ctx.exitWithStatus) {
                        ctx.exitWithStatus = status;
                    }
                }
            }
            ctx.outputs[_this.id] = status;
            return status;
        })();
    }
    /**
   *
   * @param instruction
   * @param ctx
   */ _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            let status;
            let caching = null;
            let redisClient;
            try {
                ctx.childLogger.info({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, '_call invoked with task value %s %o', _this.id, taskValue);
                let prismaArgs;
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                if (_this.yaml.authz) {
                    ctx.childLogger.info({
                        'workflow_name': _this.workflow_name,
                        'task_id': _this.id
                    }, 'invoking authz workflow, creating new ctx');
                    let args = yield (0, _scriptRuntime.default)(ctx, _this.yaml.authz.args, taskValue);
                    const newCtx = ctx.cloneWithNewData(args);
                    let allow = yield _this.yaml.authz(newCtx, taskValue);
                    if (allow.success) {
                        if (allow.data === false) {
                            ctx.exitWithStatus = new GSStatus(false, 403, allow.message || 'Unauthorized');
                            return ctx.exitWithStatus;
                        } else if (_lodash.default.isPlainObject(allow.data)) {
                            prismaArgs = allow.data;
                        }
                    }
                }
                if (_this.caching) {
                    caching = yield (0, _scriptRuntime.default)(ctx, _this.caching, taskValue);
                    // @ts-ignore
                    redisClient = global.datasources[_config.default.caching].client;
                    if (caching === null || caching === void 0 ? void 0 : caching.invalidate) {
                        ctx.childLogger.info({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        }, 'invalidating cache for %s', caching === null || caching === void 0 ? void 0 : caching.invalidate);
                        yield redisClient.del(caching.invalidate);
                    }
                    if (!(caching === null || caching === void 0 ? void 0 : caching.force)) {
                        // check in cache and return
                        status = yield redisClient.get(caching === null || caching === void 0 ? void 0 : caching.key);
                        if (status) {
                            ctx.childLogger.info({
                                'workflow_name': _this.workflow_name,
                                'task_id': _this.id
                            }, 'reading result from cache');
                            status = JSON.parse(status);
                            ctx.outputs[_this.id] = status;
                            return status;
                        }
                    }
                }
                let args = _this.args;
                if (_this.args_script) {
                    args = yield (0, _scriptRuntime.default)(ctx, _this.args_script, taskValue);
                    if (args == 'Error in parsing script') {
                        throw ctx.exitWithStatus;
                    }
                }
                ctx.childLogger.info({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, 'args after evaluation: %s %o', _this.id, args);
                if (prismaArgs) {
                    args.data = _lodash.default.merge(args.data, prismaArgs);
                    ctx.childLogger.info({
                        'workflow_name': _this.workflow_name,
                        'task_id': _this.id
                    }, 'merged args with authz args.data: %o', args);
                }
                ctx.childLogger.setBindings({
                    'workflow_name': '',
                    'task_id': ''
                });
                if (_this.fnScript) {
                    var _this_nativeFunctions;
                    ctx.childLogger.setBindings({
                        'workflow_name': _this.workflow_name,
                        'task_id': _this.id
                    });
                    let s = yield (0, _scriptRuntime.default)(ctx, _this.fnScript, taskValue);
                    ctx.childLogger.setBindings({
                        'workflow_name': '',
                        'task_id': ''
                    });
                    _this.fn = (_this_nativeFunctions = _this.nativeFunctions) === null || _this_nativeFunctions === void 0 ? void 0 : _this_nativeFunctions[s];
                    if (!_this.fn) {
                        var _this_workflows;
                        _this.fn = (_this_workflows = _this.workflows) === null || _this_workflows === void 0 ? void 0 : _this_workflows[s];
                        _this.isSubWorkflow = true;
                    }
                    ctx.childLogger.info({
                        'workflow_name': _this.workflow_name,
                        'task_id': _this.id
                    }, `invoking dynamic fn: ${s}`);
                }
                if (_this.fn instanceof GSFunction) {
                    if (_this.isSubWorkflow) {
                        ctx.childLogger.info({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        }, 'isSubWorkflow, creating new ctx');
                        ctx.childLogger.setBindings({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        });
                        const newCtx = ctx.cloneWithNewData(args);
                        ctx.childLogger.setBindings({
                            'workflow_name': '',
                            'task_id': ''
                        });
                        status = yield _this.fn(newCtx, taskValue);
                    } else {
                        ctx.childLogger.info({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        }, 'No isSubWorkflow, continuing in the same ctx');
                        status = yield _this.fn(ctx, taskValue);
                    }
                } else {
                    _this.args = args;
                    status = yield _this._executefn(ctx, taskValue);
                }
            } catch (err) {
                ctx.childLogger.error({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                }, 'Caught error in evaluation in task id: %s, error: %o', _this.id, err);
                status = new GSStatus(false, 500, err.message, `Caught error from execution in task id ${_this.id}`);
            }
            status = yield _this.handleError(ctx, status, taskValue);
            if (caching && caching.key) {
                if ((status === null || status === void 0 ? void 0 : status.success) || caching.cache_on_failure) {
                    ctx.childLogger.info({
                        'workflow_name': _this.workflow_name,
                        'task_id': _this.id
                    }, 'Store result in cache');
                    yield redisClient.set(caching.key, JSON.stringify(status), {
                        EX: caching.expires
                    });
                }
            }
            return status;
        })();
    }
    constructor(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow, fnScript){
        var _this_yaml_authz;
        super('return arguments.callee._observability.apply(arguments.callee, arguments)');
        _define_property(this, "yaml", void 0);
        _define_property(this, "id", void 0 // can be dot separated fqn
        );
        _define_property(this, "args", void 0);
        _define_property(this, "args_script", void 0);
        _define_property(this, "fn", void 0);
        _define_property(this, "onError", void 0);
        _define_property(this, "retry", void 0);
        _define_property(this, "isSubWorkflow", void 0);
        _define_property(this, "logs", void 0);
        _define_property(this, "metrics", void 0);
        _define_property(this, "workflow_name", void 0);
        _define_property(this, "workflows", void 0);
        _define_property(this, "nativeFunctions", void 0);
        _define_property(this, "fnScript", void 0);
        _define_property(this, "caching", void 0);
        this.yaml = yaml;
        this.id = yaml.id || yaml.workflow_name;
        this.fn = _fn;
        this.workflow_name = yaml.workflow_name;
        this.workflows = workflows;
        this.nativeFunctions = nativeFunctions;
        this.fnScript = fnScript;
        this.args = args || {};
        const str = JSON.stringify(this.args);
        if (str.match(/<(.*?)%/) && str.includes('%>') || str.match(/(^|\/):([^/]+)/)) {
            this.args_script = (0, _utils.compileScript)(this.args);
        }
        this.onError = yaml.on_error;
        if (this.onError && this.onError.response) {
            if (!(this.onError.response instanceof Function)) {
                this.onError.response = (0, _utils.compileScript)(this.onError.response);
            }
        }
        if ((_this_yaml_authz = this.yaml.authz) === null || _this_yaml_authz === void 0 ? void 0 : _this_yaml_authz.args) {
            var _this_yaml_authz1;
            this.yaml.authz.args = (0, _utils.compileScript)((_this_yaml_authz1 = this.yaml.authz) === null || _this_yaml_authz1 === void 0 ? void 0 : _this_yaml_authz1.args);
        }
        // retry
        this.retry = yaml.retry;
        if (this.retry) {
            if (this.retry.interval) {
                this.retry.interval = (0, _parseduration.default)(this.retry.interval.replace(/^PT/i, ''));
            }
            if (this.retry.min_interval) {
                this.retry.min_interval = (0, _parseduration.default)(this.retry.min_interval.replace(/^PT/i, ''));
            }
            if (this.retry.max_interval) {
                this.retry.max_interval = (0, _parseduration.default)(this.retry.max_interval.replace(/^PT/i, ''));
            }
        }
        this.isSubWorkflow = isSubWorkflow;
        if (this.yaml.logs) {
            var _this_logs, _this_logs1;
            this.logs = this.yaml.logs;
            if ((_this_logs = this.logs) === null || _this_logs === void 0 ? void 0 : _this_logs.before) {
                if (!(this.logs.before.attributes instanceof Function)) {
                    this.logs.before.attributes.task_id = this.id;
                    this.logs.before.attributes.workflow_name = this.workflow_name;
                    this.logs.before.attributes = (0, _utils.compileScript)(this.logs.before.attributes);
                }
            }
            if ((_this_logs1 = this.logs) === null || _this_logs1 === void 0 ? void 0 : _this_logs1.after) {
                if (!(this.logs.after.attributes instanceof Function)) {
                    this.logs.after.attributes.task_id = this.id;
                    this.logs.after.attributes.workflow_name = this.workflow_name;
                    this.logs.after.attributes = (0, _utils.compileScript)(this.logs.after.attributes);
                }
            }
        }
        // metrics
        if (this.yaml.metrics) {
            this.metrics = this.yaml.metrics;
            // @ts-ignore
            for (let metric of this.metrics){
                metric.labels.task_id = this.id;
                metric.labels.workflow_name = this.workflow_name;
                switch(metric.type){
                    case 'counter':
                        metric.obj = new _metrics.default.Counter({
                            name: metric.name,
                            help: metric.help,
                            labelNames: Object.keys(metric.labels || {})
                        });
                        break;
                    case 'gauge':
                        metric.obj = new _metrics.default.Gauge({
                            name: metric.name,
                            help: metric.help,
                            labelNames: Object.keys(metric.labels || {})
                        });
                        break;
                    case 'histogram':
                        metric.obj = new _metrics.default.Histogram({
                            name: metric.name,
                            help: metric.help,
                            labelNames: Object.keys(metric.labels || {})
                        });
                        break;
                    case 'summary':
                        metric.obj = new _metrics.default.Summary({
                            name: metric.name,
                            help: metric.help,
                            labelNames: Object.keys(metric.labels || {})
                        });
                        break;
                    default:
                        _logger.logger.error({
                            'workflow_name': this.workflow_name,
                            'task_id': this.id
                        }, 'Invalid metric type %s, it should be one of counter,summary,histogram,gauge', metric.type);
                        process.exit(1);
                }
                for (let key of Object.keys(metric)){
                    if (![
                        'type',
                        'name',
                        'obj',
                        'timer',
                        'help'
                    ].includes(key)) {
                        metric[key] = (0, _utils.compileScript)(metric[key]);
                    }
                }
            }
        }
        //caching
        if (this.yaml.caching) {
            this.caching = (0, _utils.compileScript)(this.yaml.caching);
        }
    }
}
class GSSeriesFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            ctx.childLogger.info({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, `GSSeriesFunction. Executing tasks with ids: ${_this.args.map((task)=>task.id)}`);
            let ret;
            for (const child of _this.args){
                ret = yield child(ctx, taskValue);
                if (ctx.exitWithStatus) {
                    if (child.yaml.isEachParallel) {
                        ctx.childLogger.debug({
                            'workflow_name': _this.workflow_name,
                            'task_id': _this.id
                        }, 'isEachParallel: %s, ret: %o', child.yaml.isEachParallel, ret);
                        ctx.outputs[_this.id] = ret;
                        return ret;
                    } else {
                        ctx.outputs[_this.id] = ctx.exitWithStatus;
                        return ctx.exitWithStatus;
                    }
                }
            }
            ctx.childLogger.setBindings({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            });
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'this.id: %s, output: %o', _this.id, ret.data);
            ctx.outputs[_this.id] = ret;
            return ret;
        })();
    }
}
class GSDynamicFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, `GSDynamicFunction. Executing tasks with ids: ${_this.args.map((task)=>task.id)}`);
            let ret;
            for (const child of _this.args){
                ret = yield child(ctx, taskValue);
                if (ctx.exitWithStatus) {
                    ctx.outputs[_this.id] = ctx.exitWithStatus;
                    return ctx.exitWithStatus;
                }
            }
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'this.id: %s, output: %s', _this.id, ret.data);
            if (ret.success && typeof ret.data === 'string') {
                ctx.outputs[_this.id] = yield _this.workflows[ret.data](ctx, taskValue);
            } else {
                return _this.handleError(ctx, ret, taskValue);
            }
            return ctx.outputs[_this.id];
        })();
    }
}
class GSParallelFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, `GSParallelFunction. Executing tasks with ids: ${_this.args.map((task)=>task.id)}`);
            const promises = [];
            for (const child of _this.args){
                promises.push(child(ctx, taskValue));
            }
            yield Promise.all(promises);
            const outputs = [];
            const status = new GSStatus(true, 200, '', outputs);
            let output;
            for (const child of _this.args){
                output = ctx.outputs[child.id];
                outputs.push(output);
            }
            ctx.outputs[_this.id] = status;
            return status;
        })();
    }
}
class GSSwitchFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            ctx.childLogger.info({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'GSSwitchFunction');
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'inside switch executor: %o', _this.args);
            // tasks incase of series, parallel and condition, cases should be converted to args
            let [value, cases] = _this.args;
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'condition: %s', value);
            if (_this.condition_script) {
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                value = yield (0, _scriptRuntime.default)(ctx, _this.condition_script, taskValue);
                ctx.childLogger.setBindings({
                    'workflow_name': '',
                    'task_id': ''
                });
            }
            if (cases[value]) {
                yield cases[value](ctx, taskValue);
                ctx.outputs[_this.id] = ctx.outputs[cases[value].id];
            } else {
                //check for default otherwise error
                if (cases.default) {
                    yield cases.default(ctx, taskValue);
                    ctx.outputs[_this.id] = ctx.outputs[cases.default.id];
                } else {
                    //error
                    ctx.outputs[_this.id] = new GSStatus(false, undefined, `case ${value} is missing and no default found in switch`);
                }
            }
            return ctx.outputs[_this.id];
        })();
    }
    constructor(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow){
        super(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow);
        _define_property(this, "condition_script", void 0);
        const [condition, cases] = this.args;
        if (typeof condition == 'string' && condition.match(/<(.*?)%/) && condition.includes('%>')) {
            this.condition_script = (0, _utils.compileScript)(condition);
        }
    }
}
class GSIFFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            ctx.childLogger.info({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'GSIFFunction');
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'inside GSIFFunction executor: %o', _this.args);
            // tasks incase of series, parallel and condition, cases should be converted to args
            let [value, task] = _this.args;
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'condition: %s', value);
            if (_this.condition_script) {
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                value = yield (0, _scriptRuntime.default)(ctx, _this.condition_script, taskValue);
                ctx.childLogger.setBindings({
                    'workflow_name': '',
                    'task_id': ''
                });
            }
            if (value) {
                ctx.outputs[_this.id] = yield _this.task(ctx, taskValue);
            } else {
                if (_this.else_fn) {
                    ctx.outputs[_this.id] = yield _this.else_fn(ctx, taskValue);
                } else {
                    ctx.outputs[_this.id] = new GSStatus(false, undefined, `condition not matching and no else present`);
                }
            }
            return ctx.outputs[_this.id];
        })();
    }
    constructor(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow){
        super(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow);
        _define_property(this, "condition_script", void 0);
        _define_property(this, "task", void 0);
        _define_property(this, "else_fn", void 0);
        const [condition, task, else_fn] = this.args;
        if (typeof condition == 'string' && condition.match(/<(.*?)%/) && condition.includes('%>')) {
            this.condition_script = (0, _utils.compileScript)(condition);
        }
        this.task = task;
        this.else_fn = else_fn;
    }
}
class GSEachParallelFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, `GSEachParallelFunction. Executing tasks with ids: ${_this.args.map((task)=>task.id)}`);
            let [value, task] = _this.args;
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'value: %o', value);
            if (_this.value_script) {
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                value = yield (0, _scriptRuntime.default)(ctx, _this.value_script, taskValue);
                ctx.childLogger.setBindings({
                    'workflow_name': '',
                    'task_id': ''
                });
            }
            let i = 0;
            if (!Array.isArray(value)) {
                ctx.outputs[_this.id] = new GSStatus(false, undefined, `GSEachParallel value is not an array`);
                return ctx.outputs[_this.id];
            }
            const promises = [];
            let outputs = [];
            let status;
            let failedTasksCount = 0;
            for (const val of value){
                promises.push(task(ctx, val));
            }
            outputs = yield Promise.all(promises);
            status = new GSStatus(true, 200, '', outputs);
            for (const output of outputs){
                if (!output.success) {
                    failedTasksCount++;
                }
            }
            delete ctx.exitWithStatus;
            ctx.outputs[_this.id] = status;
            // if the all the tasks get failed then check on_error at each_parallel loop level
            if (failedTasksCount == value.length && value.length > 0) {
                status.success = false;
                status.code = 500;
                return _this.handleError(ctx, status, taskValue);
            }
            return status;
        })();
    }
    constructor(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow){
        super(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow);
        _define_property(this, "value_script", void 0);
        const [value, cases] = this.args;
        if (typeof value == 'string' && value.match(/<(.*?)%/) && value.includes('%>')) {
            this.value_script = (0, _utils.compileScript)(value);
        }
    }
}
class GSEachSeriesFunction extends GSFunction {
    _call(ctx, taskValue) {
        var _this = this;
        return _async_to_generator(function*() {
            let [value, task] = _this.args;
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, 'value: %o', value);
            if (_this.value_script) {
                ctx.childLogger.setBindings({
                    'workflow_name': _this.workflow_name,
                    'task_id': _this.id
                });
                value = yield (0, _scriptRuntime.default)(ctx, _this.value_script, taskValue);
                ctx.childLogger.setBindings({
                    'workflow_name': '',
                    'task_id': ''
                });
            }
            if (!Array.isArray(value)) {
                ctx.outputs[_this.id] = new GSStatus(false, undefined, `GsEachSeries is value is not an array`);
                return ctx.outputs[_this.id];
            }
            ctx.childLogger.debug({
                'workflow_name': _this.workflow_name,
                'task_id': _this.id
            }, `GSEachSeriesFunction. Executing tasks with ids: ${_this.args.map((task)=>task.id)}`);
            const outputs = [];
            const status = new GSStatus(true, 200, '', outputs);
            let taskRes;
            let failedTasksCount = 0;
            for (const val of value){
                taskRes = yield task(ctx, val);
                if (!taskRes.success) {
                    failedTasksCount++;
                }
                if (ctx.exitWithStatus) {
                    ctx.outputs[_this.id] = ctx.exitWithStatus;
                    outputs.push(ctx.outputs[_this.id]);
                    break; // break from for loop when continue is false for any task_value in each_sequential.
                }
                outputs.push(taskRes);
            }
            delete ctx.exitWithStatus; // exitWithStatus is removed from ctx so that other tasks (outside each_sequential loop) can be continued.
            ctx.outputs[_this.id] = status;
            // if the all the tasks get failed then check on_error at each_sequential loop level
            if (failedTasksCount == value.length && value.length > 0) {
                status.success = false;
                status.code = 500;
                return _this.handleError(ctx, status, taskValue);
            }
            return ctx.outputs[_this.id];
        })();
    }
    constructor(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow){
        super(yaml, workflows, nativeFunctions, _fn, args, isSubWorkflow);
        _define_property(this, "value_script", void 0);
        const [value, cases] = this.args;
        if (typeof value == 'string' && value.match(/<(.*?)%/) && value.includes('%>')) {
            this.value_script = (0, _utils.compileScript)(value);
        }
    }
}
class GSStatus {
    constructor(success = true, code, message, data, headers){
        _define_property(this, "success", void 0);
        _define_property(this, "code", void 0);
        _define_property(this, "message", void 0);
        _define_property(this, "data", void 0);
        _define_property(this, "headers", void 0);
        this.message = message;
        this.code = code;
        this.success = success;
        this.headers = headers;
        this.data = data;
    }
}
class GSCloudEvent {
    cloneWithNewData(data) {
        return new GSCloudEvent(this.id, this.type, this.time, this.source, this.specversion, _lodash.default.cloneDeep(data), this.channel, this.actor, this.metadata);
    }
    constructor(id, type, time, source, specversion, data, channel, actor, metadata){
        //Cloud event format common fields
        _define_property(this, "id", void 0 //This should be the request id of distributed context
        );
        _define_property(this, "time", void 0);
        _define_property(this, "specversion", void 0);
        _define_property(this, "type", void 0 //URI of this event
        );
        _define_property(this, "source", void 0);
        _define_property(this, "channel", void 0);
        _define_property(this, "actor", void 0);
        //JSON schema: This data will be validated in the function definition in YAML. In __args.schema
        _define_property(this, "data", void 0 //{body, params, query, headers}, flattened and merged into a single object
        );
        _define_property(this, "metadata", void 0);
        this.id = id;
        this.type = type;
        this.channel = channel;
        this.actor = actor;
        this.time = time;
        this.metadata = metadata;
        this.source = source;
        this.data = data;
        this.specversion = specversion;
    }
}
class GSContext {
    cloneWithNewData(data) {
        var _this_inputs;
        return new GSContext(this.config, this.datasources, (_this_inputs = this.inputs) === null || _this_inputs === void 0 ? void 0 : _this_inputs.cloneWithNewData(data), this.mappings, this.plugins, this.logger, this.childLogger);
    }
    addLogEvent(event) {
        var _this_log_events;
        (_this_log_events = this.log_events) === null || _this_log_events === void 0 ? void 0 : _this_log_events.push(event);
    //also push to the logging backend
    }
    constructor(config, datasources, event, mappings, plugins, logger, childLogger){
        _define_property(this, "inputs", void 0 //The very original event for which this workflow context was created
        );
        _define_property(this, "outputs", void 0 //DAG result. This context has a trace history and responses of all instructions in the DAG are stored in this object
        );
        _define_property(this, "log_events", []);
        _define_property(this, "config", void 0 //app config
        );
        _define_property(this, "datasources", void 0 //app config
        );
        _define_property(this, "mappings", void 0);
        _define_property(this, "plugins", void 0);
        _define_property(this, "exitWithStatus", void 0);
        _define_property(this, "logger", void 0);
        _define_property(this, "childLogger", void 0);
        this.inputs = event;
        this.config = config;
        this.outputs = {};
        this.datasources = datasources;
        this.mappings = mappings;
        this.plugins = plugins;
        this.logger = logger;
        this.childLogger = childLogger;
        childLogger.debug('inputs for context %o', event.data);
    }
}
class GSLogEvent {
    constructor(type, data, attributes = {}, timestamp = new Date()){
        _define_property(this, "type", void 0);
        _define_property(this, "data", void 0);
        _define_property(this, "timestamp", void 0);
        _define_property(this, "attributes", void 0);
        this.type = type;
        this.data = data;
        this.attributes = attributes;
        this.timestamp = timestamp;
    }
}
class GSActor {
    constructor(type, tenant_id, name, id, data){
        _define_property(this, "type", void 0);
        _define_property(this, "tenant_id", void 0);
        _define_property(this, "name", void 0 // Fully qualified name
        );
        _define_property(this, "id", void 0 // id of the actor
        );
        _define_property(this, "data", void 0 //Other information in key value pairs. For example IP address
        );
        this.type = type;
        this.tenant_id = tenant_id;
        this.name = name;
        this.id = id;
        this.data = data;
    }
}
