/*
 * You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
 * Â© 2022 Mindgrep Technologies Pvt Ltd
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    loadJsonSchemaForEvents: function() {
        return loadJsonSchemaForEvents;
    },
    validateRequestSchema: function() {
        return validateRequestSchema;
    },
    validateResponseSchema: function() {
        return validateResponseSchema;
    }
});
const _logger = require("../logger");
const _validation = /*#__PURE__*/ _interop_require_wildcard(require("./validation"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function loadJsonSchemaForEvents(eventObj) {
    _logger.logger.debug('Loading JSON Schema for events %s', Object.keys(eventObj));
    _logger.logger.debug('eventObj: %o', eventObj);
    return new Promise((resolve, reject)=>{
        Object.keys(eventObj).forEach(function(topic) {
            // Add body schema in ajv for each content_type per topic
            /* TODO: Right now, we are assuming that there is going to be one content_type only i.e. application/json
                  This needs to be enhanced in fututre when multiple content_type will be supported
          */ const eventObjTopic = eventObj[topic];
            if ((0, _validation.isValidEvent)(eventObjTopic, topic)) {
                var _eventObjTopic_body, //just like OpenAPI Spec but with body instead of requestBody
                _eventObjTopic_data_schema_body, _eventObjTopic_data_schema, _eventObjTopic_data, _eventObjTopic_data_schema1, _eventObjTopic_data1;
                //Object.keys(eventObjTopic).forEach(function(topic) {
                const body_content = (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : (_eventObjTopic_body = eventObjTopic.body) === null || _eventObjTopic_body === void 0 ? void 0 : _eventObjTopic_body.content) || (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : (_eventObjTopic_data = eventObjTopic.data) === null || _eventObjTopic_data === void 0 ? void 0 : (_eventObjTopic_data_schema = _eventObjTopic_data.schema) === null || _eventObjTopic_data_schema === void 0 ? void 0 : (_eventObjTopic_data_schema_body = _eventObjTopic_data_schema.body) === null || _eventObjTopic_data_schema_body === void 0 ? void 0 : _eventObjTopic_data_schema_body.content); //Legacy
                if (body_content) {
                    Object.keys(body_content).forEach(function(k) {
                        const content_schema = body_content[k].schema;
                        if (content_schema) {
                            _logger.logger.debug('adding body schema for %s', topic);
                            _logger.logger.debug('content_schema %o', content_schema);
                            if (!_validation.default.getSchema(topic)) {
                                _validation.default.addSchema(content_schema, topic);
                            }
                        }
                    });
                }
                // Add params schema in ajv for each param per topic
                const params = (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.parameters) || (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.params) || (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : (_eventObjTopic_data1 = eventObjTopic.data) === null || _eventObjTopic_data1 === void 0 ? void 0 : (_eventObjTopic_data_schema1 = _eventObjTopic_data1.schema) === null || _eventObjTopic_data_schema1 === void 0 ? void 0 : _eventObjTopic_data_schema1.params);
                let paramSchema = {};
                if (params) {
                    for (let param of params){
                        if (param.schema) {
                            if (!paramSchema[param.in]) {
                                paramSchema[param.in] = {
                                    type: 'object',
                                    required: [],
                                    properties: {}
                                };
                            }
                            if (param.required) {
                                paramSchema[param.in].required.push(param.name);
                            }
                            let schema = param.schema;
                            if (param.allow_empty_value) {
                                param.schema.nullable = true;
                            }
                            paramSchema[param.in].properties[param.name] = schema;
                        }
                    }
                }
                for(let schema in paramSchema){
                    _logger.logger.info('adding param schema for %s', topic);
                    _logger.logger.debug('param schema: %o', paramSchema[schema]);
                    const topic_param = topic + ':' + schema;
                    if (!_validation.default.getSchema(topic_param)) {
                        _validation.default.addSchema(paramSchema[schema], topic_param);
                    }
                }
                // Add responses schema in ajv for each response per topic
                const responses = eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.responses;
                if (responses) {
                    Object.keys(responses).forEach(function(k) {
                        var _responses_k_content_applicationjson, _responses_k_content, _responses_k, //Exactly as OpenApi spec
                        _responses_k_schema_data_content_applicationjson, _responses_k_schema_data_content, _responses_k_schema_data, _responses_k_schema, _responses_k1;
                        const response_s = ((_responses_k = responses[k]) === null || _responses_k === void 0 ? void 0 : (_responses_k_content = _responses_k.content) === null || _responses_k_content === void 0 ? void 0 : (_responses_k_content_applicationjson = _responses_k_content['application/json']) === null || _responses_k_content_applicationjson === void 0 ? void 0 : _responses_k_content_applicationjson.schema) || ((_responses_k1 = responses[k]) === null || _responses_k1 === void 0 ? void 0 : (_responses_k_schema = _responses_k1.schema) === null || _responses_k_schema === void 0 ? void 0 : (_responses_k_schema_data = _responses_k_schema.data) === null || _responses_k_schema_data === void 0 ? void 0 : (_responses_k_schema_data_content = _responses_k_schema_data.content) === null || _responses_k_schema_data_content === void 0 ? void 0 : (_responses_k_schema_data_content_applicationjson = _responses_k_schema_data_content['application/json']) === null || _responses_k_schema_data_content_applicationjson === void 0 ? void 0 : _responses_k_schema_data_content_applicationjson.schema); //Legacy implementation
                        if (response_s) {
                            const response_schema = response_s;
                            const topic_response = topic + ':responses:' + k;
                            //console.log("topic_response: ",topic_response)
                            if (!_validation.default.getSchema(topic_response)) {
                                _validation.default.addSchema(response_schema, topic_response);
                            }
                        }
                    });
                }
            } else {
                process.exit(1);
            }
        });
        resolve(1);
    });
}
function validateRequestSchema(topic, event, eventSpec) {
    var _eventSpec_data_schema, _eventSpec_data, //structure like open api spec
    _eventSpec_data_schema1, _eventSpec_data1;
    let status;
    // Validate event.data.body
    const hasSchema = (eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.body) || (eventSpec === null || eventSpec === void 0 ? void 0 : (_eventSpec_data = eventSpec.data) === null || _eventSpec_data === void 0 ? void 0 : (_eventSpec_data_schema = _eventSpec_data.schema) === null || _eventSpec_data_schema === void 0 ? void 0 : _eventSpec_data_schema.body);
    if (event.data.body && hasSchema) {
        _logger.childLogger.info('event body and eventSpec exist');
        _logger.childLogger.debug('event.data.body: %o', event.data.body);
        const ajv_validate = _validation.default.getSchema(topic);
        if (ajv_validate) {
            _logger.childLogger.debug('ajv_validate for body');
            if (!ajv_validate(event.data.body)) {
                _logger.childLogger.error('ajv_validate failed');
                status = {
                    success: false,
                    code: 400,
                    message: ajv_validate.errors[0].message,
                    data: ajv_validate.errors[0]
                };
                return status;
            } else {
                _logger.childLogger.info('ajv_validate success for body');
                status = {
                    success: true
                };
            }
        } else {
            status = {
                success: true
            };
        }
    } else if (!event.data.body && hasSchema) {
        status = {
            success: false,
            code: 400,
            message: 'Body not found in request but specified in the event schema'
        };
        return status;
    } else {
        //Body is not present in request and not specified in the event schema
        status = {
            success: true
        };
    }
    const params = (eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.parameters) || (eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.params) || (eventSpec === null || eventSpec === void 0 ? void 0 : (_eventSpec_data1 = eventSpec.data) === null || _eventSpec_data1 === void 0 ? void 0 : (_eventSpec_data_schema1 = _eventSpec_data1.schema) === null || _eventSpec_data_schema1 === void 0 ? void 0 : _eventSpec_data_schema1.params); //Legacy
    // Validate event.data['params']
    let MAP = {
        path: 'params',
        header: 'headers',
        query: 'query',
        cookie: 'cookie'
    };
    _logger.childLogger.debug('ajv_validate for params');
    if (params) {
        for(let param in MAP){
            const topic_param = topic + ':' + param;
            const ajv_validate = _validation.default.getSchema(topic_param);
            _logger.childLogger.debug('topic_param: %s', topic_param);
            if (ajv_validate) {
                if (!ajv_validate(event.data[MAP[param]])) {
                    ajv_validate.errors[0].message += ' in ' + param;
                    status = {
                        success: false,
                        code: 400,
                        message: ajv_validate.errors[0].message,
                        data: ajv_validate.errors[0]
                    };
                    return status;
                } else {
                    _logger.childLogger.info('ajv_validate success for params');
                    status = {
                        success: true
                    };
                }
            }
        }
    }
    return status;
}
function validateResponseSchema(topic, gs_status) {
    let status;
    //console.log("gs_status: ",gs_status)
    if (gs_status.data) {
        const topic_response = topic + ':responses:' + gs_status.code;
        const ajv_validate = _validation.default.getSchema(topic_response);
        if (ajv_validate) {
            if (!ajv_validate(gs_status.data)) {
                _logger.childLogger.error('ajv_validate failed');
                status = {
                    success: false,
                    code: 500,
                    message: ajv_validate.errors[0].message,
                    data: ajv_validate.errors[0]
                };
                return status;
            } else {
                _logger.childLogger.info('ajv_validate success');
                status = {
                    success: true
                };
            }
        } else {
            status = {
                success: true
            };
        }
    } else {
        status = {
            success: true
        };
    }
    return status;
}
